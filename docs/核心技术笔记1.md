### <核心技术>笔记1
+ Java里int无法转换为boolean，所以if(a)这种写法是不能编译通过的；
+ 无法从静态上下文中引用非静态变量，静态方面里不能访问非静态变量额；
```
class A {
	int a = 10;
	public static void main(String[] args){
		if(a==10){
			System.out.println("Test pass!");
		}
	}
}
```
+ 浮点型数字默认就是double型
   1. float f = 1.0;编译不通过；需要改成1.0f;或者1.0F;
   2. double d = 1.01f;编译可以通过；但是打印会变成1.0099999904632568； 
+ 局部变量需初始化后才能使用否则编译不通过；类变量不必初始化，会有默认初始值；但是最好不要依赖于系统默认初始值；
+ switch的case标签可以是char\byte\short\int;从SE7开始case标签还可以是字符串字面量；
+ 需要获取或设置一个实例域的值，提供以下三项内容：
   1. 一个私有的数据域；(private)
   2. 一个共有的域访问器方法；(getter)
   3. 一个共有的域更改器方法；(setter)
+ 不要编写返回引用可变对象的访问器方法。如果需要，使用clone()方法；return Date.clone();
+ Java语言总是采用按值调用；参数如果是一个对象，只是传递了对象地址的一个拷贝；
+ 调用构造器的具体处理步骤：
   1. 所有数据域被初始化为默认值（0/false/null）
   2. 按照在类中出现的顺序，依次执行初始化语句和初始化块{}
   3. 如果构造器第一行调用了第二个构造器(this())，则执行第二个构造器主体
   4. 执行这个构造器的主体
+ 类设计的技巧：
   1. 一定要保证数据私有
   2. 一定要对数据初始化
   3. 不要在类中使用过多的基本类型
   4. 不是所有的类都需要独立的域访问器和更改器
   5. 将职责过多的类进行分解
   6. 类名和方法名要能够体现它们的职责
+ 类的强制类型转换
   1. 只能在继承层次内进行类型转换
   2. 子类转换为超类没问题
   3. 超类转换成子类可能会抛出异常（声明为超类的子类当然不会），应该使用instanceof进行检查
   4. 方法调用时还是以实际的引用类型为准哦
+ 重写Object类中的方法
   1. 重写equals方法，标准的5个步骤，分清是在子类还是父类中比较，instanceof 还是 getClass();对象的比较用Objects.equals()
   2. 重写hashCode方法，使用Objects.hash()就行了；
   3. 重写toString,在父类中使用getClass()就行；
